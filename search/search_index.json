{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>This web documentation site is made for portfolio and created utils made by heart to help your game to be more optimize/readable</p> <p>Availables Modules:</p> <ul> <li>Task</li> <li>Buffer</li> </ul> <p>Contact:</p> <ul> <li>Discord: .d_0010</li> </ul> <p>Support:</p> <ul> <li>Paypal: </li> </ul>"},{"location":"Buffer/","title":"Buffer","text":"<p>Get Buffer: Buffer</p> <p>A better Buffer Writer/Reader Module</p> <p>Learn more about Buffer: buffer-library</p> <p>Allowed Type:</p> <ul> <li>Strings</li> <li>Numbers</li> <li>Booleans</li> <li>Array (String,Numbers,Booleans only)</li> </ul>"},{"location":"Buffer/#get-started","title":"Get Started","text":"Code <pre><code>    local ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\n\n    local BufferModule = require(ReplicatedStorage.Buffer)\n\n    local _buffer = BufferModule.new(0) --&gt; (auto allocate is allowed in this module)\n    _buffer:WriteF64(math.huge) -- will automaticly allocate 8 byts\n    print(_buffer:ReadF64(0)) -- return inf\n</code></pre>"},{"location":"Buffer/#writing-array","title":"Writing array","text":"Code <pre><code>    local ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\n\n    local BufferModule = require(ReplicatedStorage.Buffer)\n\n    local _buffer = BufferModule.new(0) --&gt; (auto allocate is allowed in this module)\n\n    --[[\n        :WriteArray()\n        the first argument is a table of value that want to be written\n        and the second argument is a table of all types in order ex\n        25 = I8,\n        \"hi\" = String,\n        math.huge = \"F64\"\n    ]]\n    _buffer:WriteArray({25,\"Hi\",math.huge},{\"I8\",\"String\",\"F64\"})\n    --[[\n        To read values you need to call the exact Readable Type:\n        exemple:\n            ReadI8()\n            ReadString()\n            ReadF64()\n    ]]\n</code></pre>"},{"location":"Buffer/#writingreading-booleans","title":"Writing/Reading Booleans","text":"Code <pre><code>local ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\n\nlocal BufferModule = require(ReplicatedStorage.Buffer)\n\nlocal _buffer = BufferModule.new(0) --&gt; (auto allocate is allowed in this module)\n_buffer:WriteBool1({true,1,false,false,workspace.Baseplate,\"hi\",true,false}) -- min value 8 max value 8\nprint(_buffer:ReadBool1(8)) -- {Array of booleans}\n</code></pre>"},{"location":"Buffer/#properties-of-buffer","title":"Properties of buffer","text":"<p>.Buffer -&gt; return the current buffer who write values and read them</p> <p>.Offset -&gt; return the current offset of the buffer</p>"},{"location":"Buffer/#info","title":"Info","text":"<p>This module is still not finished but this is the first version of it</p>"},{"location":"Buffer/#version","title":"Version","text":"<p>VERSION : 1.0</p>"},{"location":"Task/","title":"Task","text":"<p>Get Task : Task</p> <p>This module handle Instance/Metatable/Connection with clean up function ex </p> <pre><code>    {\"Destroy\",\"Disconnect\",\"DisconnectAll\",\"DoCleaning\",\"Clean\"}\n</code></pre> <p>More clean up function can be set directly from the module itself</p>"},{"location":"Task/#get-started","title":"Get Started","text":"ConnectionInstanceClass <pre><code>    local ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\n\n    local Task = require(ReplicatedStorage.Task)\n    --[[\n        Task.new() return a new TaskClass\n    ]]\n    local TaskHandler = Task.new()\n    TaskHandler:Add(workspace.Baseplate:GetPropertyChangedSignal(\"Position\"):Connect(function(...: any) \n        -- do stuff here\n    end)) -- Connect the function to the handler\n    TaskHandler:Destroy() -- Connection(s) will be disconnected\n</code></pre> <pre><code>    local ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\n\n    local Task = require(ReplicatedStorage.Task)\n    --[[\n        Task.new() return a new TaskClass\n    ]]\n    local TaskHandler = Task.new()\n    TaskHandler:Add(workspace.Baseplate) -- Attach the Baseplate to the task handler\n    TaskHandler:Destroy() -- Baseplate will be destroyed\n</code></pre> <pre><code>    local ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\n\n    local Task = require(ReplicatedStorage.Task)\n\n    --Create a random strict class\n    local class = {\n        Destroy = function()\n            print(\"Cleaning...\")\n        end,\n    }\n    setmetatable(class,{\n        __index = function(t,k)\n            warn(`Can't get Class::{type(k)}`)\n        end,\n        __newindex = function(t,k,v)\n            warn(`Can't set Class:{type(k)} (not a valid member)`)\n        end,\n\n    })\n    --[[\n        Task.new() return a new TaskClass\n    ]]\n    local TaskHandler = Task.new()\n    TaskHandler:Add(class) -- Added \"Class\" to the task handler\n    TaskHandler:Destroy() -- Will print \"Cleaning...\"\n</code></pre> <p>Class without clean up function</p> <p>If you try to pass a class without a single clean up function the class will be discarded and not added to the task handler.</p>"},{"location":"Task/#using-signal","title":"Using Signal","text":"<p>Exemples:</p> <p>The used signal is the from sleitnick</p> <p>link: Signal Module</p> Code <pre><code>    local ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\n\n    local Task = require(ReplicatedStorage.Task)\n    local Signal = require(ReplicatedStorage.Signal)\n\n    local TaskHandler = Task.new()\n    local signal = Signal.new()\n\n    TaskHandler:Add(signal:Connect(function(...)\n        print(...) -- Will print hello signal\n    end))\n\n    signal:Fire(\"Hello Signal\")\n\n    TaskHandler:Clean()\n\n    signal:Fire(\"Goodbye Signal\") -- This will never show\n</code></pre>"},{"location":"Task/#using-promise","title":"Using Promise","text":"<p>For promise you should prefer to use :AddPromise instead of Add</p> Code <pre><code>    local ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\n\n    local Task = require(ReplicatedStorage.Task)\n    local Promise = require(ReplicatedStorage.Promise)\n\n    local TaskHandler = Task.new()\n    TaskHandler:AddPromise(Promise.new(function(resolve,reject,onCancel) \n        -- Promise stuff here\n    end))\n    TaskHandler:Clean()\n</code></pre>"},{"location":"Task/#executing-function","title":"Executing function","text":"<p>The :Execute function allow you to directly call a function (only) instead of calling this function the clean up state</p> Code <pre><code>    local ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\n\n    local Task = require(ReplicatedStorage.Task)\n    local Promise = require(ReplicatedStorage.Promise)\n\n    local TaskHandler = Task.new()\n\n    TaskHandler:Add(function()\n        print(\"hi but on the clean up state\") -- print after :Clean()\n    end)\n\n    TaskHandler:Execute(function()\n        print(\"hi\") -- print instantly\n    end)\n\n    task.wait(1)\n\n    TaskHandler:Clean()\n</code></pre>"},{"location":"Task/#gettaskatindexindex-number","title":"GetTaskAtIndex(index : number)","text":"<p>You can get the added connection/class/instance/function from the target index</p> Code <pre><code>local ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\n\nlocal Task = require(ReplicatedStorage.Task)\nlocal Promise = require(ReplicatedStorage.Promise)\n\nlocal TaskHandler = Task.new()\n\nTaskHandler:Add(function()\n    print(\"hi but on the clean up state\") -- print after :Clean()\nend)\n\nTaskHandler:GetTaskAtIndex(1)() -- print \"hi but on the clean up state\"\n\ntask.wait(1)\n\nTaskHandler:Clean()\n</code></pre> <p>Calling function with GetTaskAtIndex</p> <p>if you call a returned function from GetTaskAtIndex at the CleanUp state of Task the same function will be called</p>"},{"location":"Task/#istask","title":"IsTask()","text":"<p>Check if the current passed table is a task Class</p> Code <pre><code>local ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\n\nlocal Task = require(ReplicatedStorage.Task)\nlocal Promise = require(ReplicatedStorage.Promise)\n\nlocal TaskHandler = Task.new()\n\nprint(Task.IsTask(TaskHandler)) -- true\nprint(Task.IsTask({})) -- false\n</code></pre>"},{"location":"Task/#info","title":"Info","text":"<p>This module is still not finished but this is the first version of it</p>"},{"location":"Task/#version","title":"Version","text":"<p>VERSION : 1.0</p>"}]}